# 220628

### 에라토스테네스의 체
   * 소수가 되는 수의 배수를 지우면 남은 건 소수가 된다.는 알고리즘 
   * 소수가 무엇인지 찾을 필요가 없으며 2부터 자기 자신을 제외한 배수가 되는 것을 지우면 된다. 
   * 아주 넓은 범위의 자연수 내에서 소수를 찾을 때는 이 알고리즘이 훨씬 빠르고 간단하다. 
   * 시간복잡도는 O(n^2)

### 브루트포스
   * 완전탐색알고리즘. 무식하게 모든 경우의 수를 다 구하는 알고리즘이다.
   * 걍 무식하게 가능한 모든 경우의 수를 탐색하는 것! 예외 없이 100프로 확률로 정답을 도출한다.
   * 알고리즘 설계의 가장 기본적인 접근 방법은 해가 존재할 것으로 예상되는 모든 영역을 전체 탐색하는 방법이다.
   * 선형 구조를 전체적으로 탐색하는 순차 탐색, 비선형 구조를 전체적으로 탐색하는 깊이 우선 탐색(DFS, Depth First Search)과 너비 우선 탐색(BFS, breadth first search)이 가장 기본적인 도구이다.
   * DFS는 브루트포스랑, BFS는 백트래킹과 관련이 깊다.
   * 예제 -> 1000원을 10원 동전, 100원 동전 n개 중 m개로 만드는 것 / 21을 10개 카드 중 3개만 골라서 더해서 가장 가까운 수 만들기
   
### 재귀
   * 장점
      * 간단한 함수 호출로 반복적 수행이 가능하다.
      * 점화식만 구하면 구현이 쉽다.
      * 동일한 연산을 반복해서 수행할 필요 없이 이전에 계산한 결과를 활용할 수 있다.
      * 변수를 여럿 만들 필요가 없다.
   * 단점
      * 두 갈래로 나뉘기 때문에 시간 복잡도가 일반 반복문보다 복잡함.
      * 탈출 조건을 적절하게 만들지 않으면 무한 루프에 빠진다. -> 스택 오버플로우에 주의해야 한다!
      * 흐름 파악이 어렵다 -> 복잡도 계산이 어렵다.
      * 오버헤드가 크다 -> 메모리 사용량이 많다. 돌아갈 포인트를 기억해야 하기 때문.